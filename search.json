[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "akey7",
    "section": "",
    "text": "Julia: Molecular Dynamics of HCl\n\n\n\n\n\n\njulia\n\n\nphysics\n\n\nchemistry\n\n\n\n\n\n\n\n\n\nMar 23, 2024\n\n\nAlicia\n\n\n\n\n\n\n\n\n\n\n\n\nJulia: Positive and Negative Definite Matrices\n\n\n\n\n\n\njulia\n\n\nmath\n\n\n\n\n\n\n\n\n\nMar 19, 2024\n\n\nAlicia\n\n\n\n\n\n\n\n\n\n\n\n\nPython: Simple Gradient Descent\n\n\n\n\n\n\npython\n\n\nmath\n\n\n\n\n\n\n\n\n\nJun 14, 2023\n\n\nAlicia\n\n\n\n\n\n\n\n\n\n\n\n\nR: FFT with fftpipe\n\n\n\n\n\n\nR\n\n\nmath\n\n\n\n\n\n\n\n\n\nDec 31, 2022\n\n\nAlicia\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Julia: Positive and Negative Definite Matrices",
    "section": "",
    "text": "These functions implement the expression, which can calculate scalar quantities when given x1 and x2 components of a 2-element vector.\n\\[ f(\\mathbf x) = \\mathbf x^T \\mathbf A \\mathbf x \\]\nIn this case, I take the matrix A to positive definite or negative definite. Then, I pass the same vectors into the function to see the behavior of positive or negative definite matrices.\n\n\nThe 2x2 identity matrix is positive definite:\n\\[\n\\begin{bmatrix}\n1 & 0 \\\\\n0 & 1 \\\\\n\\end{bmatrix}\n\\]\n\nfunction pos_definite(x1::Float64, x2::Float64)\n    A = [1.0 0.0; 0.0 1.0]\n    x = [x1; x2]\n    x' * A * x\nend\n\npos_definite (generic function with 1 method)\n\n\n\n\n\nThe following 2x2 matrix is negative definite:\n\\[\n\\begin{bmatrix}\n-1 & 0 \\\\\n0 & -2 \\\\\n\\end{bmatrix}\n\\]\n\nfunction neg_definite(x1::Float64, x2::Float64)\n    A = [-1.0 0.0; 0.0 -2.0]\n    x = [x1; x2]\n    x' * A * x\nend\n\nneg_definite (generic function with 1 method)"
  },
  {
    "objectID": "posts/post-with-code/index.html#functions-to-create-surfaces",
    "href": "posts/post-with-code/index.html#functions-to-create-surfaces",
    "title": "Julia: Positive and Negative Definite Matrices",
    "section": "",
    "text": "These functions implement the expression, which can calculate scalar quantities when given x1 and x2 components of a 2-element vector.\n\\[ f(\\mathbf x) = \\mathbf x^T \\mathbf A \\mathbf x \\]\nIn this case, I take the matrix A to positive definite or negative definite. Then, I pass the same vectors into the function to see the behavior of positive or negative definite matrices.\n\n\nThe 2x2 identity matrix is positive definite:\n\\[\n\\begin{bmatrix}\n1 & 0 \\\\\n0 & 1 \\\\\n\\end{bmatrix}\n\\]\n\nfunction pos_definite(x1::Float64, x2::Float64)\n    A = [1.0 0.0; 0.0 1.0]\n    x = [x1; x2]\n    x' * A * x\nend\n\npos_definite (generic function with 1 method)\n\n\n\n\n\nThe following 2x2 matrix is negative definite:\n\\[\n\\begin{bmatrix}\n-1 & 0 \\\\\n0 & -2 \\\\\n\\end{bmatrix}\n\\]\n\nfunction neg_definite(x1::Float64, x2::Float64)\n    A = [-1.0 0.0; 0.0 -2.0]\n    x = [x1; x2]\n    x' * A * x\nend\n\nneg_definite (generic function with 1 method)"
  },
  {
    "objectID": "posts/post-with-code/index.html#surface-plots",
    "href": "posts/post-with-code/index.html#surface-plots",
    "title": "Julia: Positive and Negative Definite Matrices",
    "section": "Surface plots",
    "text": "Surface plots\n\nPositive definite plot\n\nxs = -5:0.1:5\nys = -5:0.1:5\n\nzs = [pos_definite(x, y) for x in xs, y in ys]\n\nsurface(xs, ys, zs, title=\"Positive Definite Matrix Transform\", xlabel=\"x\", ylabel=\"y\", zlabel=\"z\", cmap=:cool)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\nNegative definite plot\n\nxs = -5:0.1:5\nys = -5:0.1:5\n\nzs = [neg_definite(x, y) for x in xs, y in ys]\n\nsurface(xs, ys, zs, title=\"Negative Definite Matrix Transform\", xlabel=\"x\", ylabel=\"y\", zlabel=\"z\", cmap=:cool)"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi! I am Alicia Michelle Farley Key, a PhD student in Structural Biology, Biochemistry, and Biophysics. This is a site where I put fun side projects I do from time to time."
  },
  {
    "objectID": "posts/positive-and-negative-definite-matrices/index.html",
    "href": "posts/positive-and-negative-definite-matrices/index.html",
    "title": "Julia: Positive and Negative Definite Matrices",
    "section": "",
    "text": "These functions implement the expression, which can calculate scalar quantities when given x1 and x2 components of a 2-element vector.\n\\[ f(\\mathbf x) = \\mathbf x^T \\mathbf A \\mathbf x \\]\nIn this case, I take the matrix A to positive definite or negative definite. Then, I pass the same vectors into the function to see the behavior of positive or negative definite matrices.\n\n\nThe 2x2 identity matrix is positive definite:\n\\[\n\\begin{bmatrix}\n1 & 0 \\\\\n0 & 1 \\\\\n\\end{bmatrix}\n\\]\n\nfunction pos_definite(x1::Float64, x2::Float64)\n    A = [1.0 0.0; 0.0 1.0]\n    x = [x1; x2]\n    x' * A * x\nend\n\npos_definite (generic function with 1 method)\n\n\n\n\n\nThe following 2x2 matrix is negative definite:\n\\[\n\\begin{bmatrix}\n-1 & 0 \\\\\n0 & -2 \\\\\n\\end{bmatrix}\n\\]\n\nfunction neg_definite(x1::Float64, x2::Float64)\n    A = [-1.0 0.0; 0.0 -2.0]\n    x = [x1; x2]\n    x' * A * x\nend\n\nneg_definite (generic function with 1 method)"
  },
  {
    "objectID": "posts/positive-and-negative-definite-matrices/index.html#functions-to-create-surfaces",
    "href": "posts/positive-and-negative-definite-matrices/index.html#functions-to-create-surfaces",
    "title": "Julia: Positive and Negative Definite Matrices",
    "section": "",
    "text": "These functions implement the expression, which can calculate scalar quantities when given x1 and x2 components of a 2-element vector.\n\\[ f(\\mathbf x) = \\mathbf x^T \\mathbf A \\mathbf x \\]\nIn this case, I take the matrix A to positive definite or negative definite. Then, I pass the same vectors into the function to see the behavior of positive or negative definite matrices.\n\n\nThe 2x2 identity matrix is positive definite:\n\\[\n\\begin{bmatrix}\n1 & 0 \\\\\n0 & 1 \\\\\n\\end{bmatrix}\n\\]\n\nfunction pos_definite(x1::Float64, x2::Float64)\n    A = [1.0 0.0; 0.0 1.0]\n    x = [x1; x2]\n    x' * A * x\nend\n\npos_definite (generic function with 1 method)\n\n\n\n\n\nThe following 2x2 matrix is negative definite:\n\\[\n\\begin{bmatrix}\n-1 & 0 \\\\\n0 & -2 \\\\\n\\end{bmatrix}\n\\]\n\nfunction neg_definite(x1::Float64, x2::Float64)\n    A = [-1.0 0.0; 0.0 -2.0]\n    x = [x1; x2]\n    x' * A * x\nend\n\nneg_definite (generic function with 1 method)"
  },
  {
    "objectID": "posts/positive-and-negative-definite-matrices/index.html#surface-plots",
    "href": "posts/positive-and-negative-definite-matrices/index.html#surface-plots",
    "title": "Julia: Positive and Negative Definite Matrices",
    "section": "Surface plots",
    "text": "Surface plots\n\nPositive definite plot\n\nxs = -5:0.1:5\nys = -5:0.1:5\n\nzs = [pos_definite(x, y) for x in xs, y in ys]\n\nsurface(xs, ys, zs, title=\"Positive Definite Matrix Transform\", xlabel=\"x\", ylabel=\"y\", zlabel=\"z\", cmap=:cool)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\nNegative definite plot\n\nxs = -5:0.1:5\nys = -5:0.1:5\n\nzs = [neg_definite(x, y) for x in xs, y in ys]\n\nsurface(xs, ys, zs, title=\"Negative Definite Matrix Transform\", xlabel=\"x\", ylabel=\"y\", zlabel=\"z\", cmap=:cool)"
  },
  {
    "objectID": "posts/moldyn/index.html",
    "href": "posts/moldyn/index.html",
    "title": "Julia: Molecular Dynamics of HCl",
    "section": "",
    "text": "Molecular dynamics models the motion of atoms within molecules using classical mechanics calculations. Molecular dynamics envisions atoms as balls on springs and calculates the accelerations of atoms within the system in a potential energy force field that has terms for several types of motions in the molecule. In this post, I will use the letter U to denote potential energy. Typical force fields model the following potentials: \\[ U = U_{stretch} + U_{angle} + U_{dihedral} + U_{improper} \\] For a complete description of the force field terms and motions, I refer the reader to Chapter 3 of the Cramer text referenced at the bottom of this document. In this project, I only model bond stretch energy so I could keep the code simple. The notation I will use in this post and code mostly comes from Chapter 3 of the Cramer text.\n\n\nThe stretch potential energy of a bond between atoms A and i is denoted Ustretch and has the following form: \\[ U_{stretch} = {1 \\over 2}k_{Ai}(r_{Ai}-r_{Ai,eq})^2 \\] Where kAi is the spring constant of the bond, rAi,eq is the equilibrium distance between atoms A and B and rAB is the instantaneous distance between the atoms. Since I am only modeling the stretch energy in this project, I will shorten Ustretch to U from here onward.\nThe first derivative of the stretch energy which is used to calculate the stretch forces acting upon an atom by the other atoms it is bonded to is: \\[ {\\partial U \\over \\partial x_A}=\\sum_{i} {\\partial U \\over \\partial r_{Ai}} {\\partial r_{Ai} \\over \\partial x_A} \\] Where the summation is over the atoms bonded to A and i refers to the other atoms. Similarly to x axis potential, the y and z potentials are: \\[ {\\partial U \\over \\partial y_A}=\\sum_{i} {\\partial U \\over \\partial r_{Ai}} {\\partial r_{Ai} \\over \\partial y_A} \\] \\[ {\\partial U \\over \\partial z_A}=\\sum_{i} {\\partial U \\over \\partial r_{Ai}} {\\partial r_{Ai} \\over \\partial z_A} \\] The partial derivatives of rAi for each x, y, z coordinate are: \\[ {\\partial r_{Ai} \\over \\partial x_A} = {x_A-x_i \\over \\sqrt{(x_A-x_i)^2 + (y_A-y_i)^2 + (z_A-z_i)^2}} \\] \\[ {\\partial r_{Ai} \\over \\partial y_A} = {y_A-y_i \\over \\sqrt{(x_A-x_i)^2 + (y_A-y_i)^2 + (z_A-z_i)^2}} \\] \\[ {\\partial r_{Ai} \\over \\partial z_A} = {z_A-z_i \\over \\sqrt{(x_A-x_i)^2 + (y_A-y_i)^2 + (z_A-z_i)^2}} \\] Finally, the partial derivative of stretch energy with respect to bond distance rAi is: \\[ {\\partial U \\over \\partial r_{Ai}} = k_{Ai}(r_{Ai}-r_{Ai,eq}) \\]\n\n\n\nThe analytical period of a harmonic oscillator that models the interatomic bonds in this simulation is: \\[ {1 \\over \\mu} = {1 \\over m_1} + {1 \\over m_2} \\]\n\\[ T = \\sqrt{\\mu \\over k_b} \\] where mu is the reduced mass, m1 and m2 are the masses of the atoms (in kg) and kb is the spring constant of the bond. T is the period of the oscillation in seconds. While I do not use this equation in the simulation, I do use it to verify the simulation is producing physically valid output.\n\n\n\nTo propagate the trajectory over time, I use the velocity Verlet algorithm. At each time step, I perform the algorithm for each atom. The steps of the algorithm are as follows: \\[ \\mathbf x_{t+1} = \\mathbf x_t + \\mathbf {v}_t \\Delta t + \\mathbf a_t (\\Delta t)^2 \\] \\[ \\mathbf v_{t+{1 \\over 2}} = \\mathbf v_t + {1 \\over 2} \\mathbf a_i \\Delta t \\] \\[ \\mathbf a_{i+1} = -{\\mathbf \\nabla_i \\over m} \\] \\[ \\mathbf v_{i+1} = \\mathbf v_{t+{1 \\over 2}} + {1 \\over 2}\\mathbf a_{i+1} \\Delta t \\]\n\n\n\nAs diagnostic metrics to assess the proper behavior of the simulation, I calculate the kinetic, potential, and total energy of the system at each time step. For the kinetic energy, I just sum over the kinetic energies of all the atoms to arrive at the total kinetic energy Ek: \\[ E_k = \\sum_i {1 \\over 2} m_i v_i^2 \\] Since the only energy is stretch energy in this simulation, I sum over the stretch energy over all atoms to find the total potential energy Ep: \\[ E_p = \\sum_i U_i \\]"
  },
  {
    "objectID": "posts/moldyn/index.html#purpose-of-this-markdown",
    "href": "posts/moldyn/index.html#purpose-of-this-markdown",
    "title": "Julia: Molecular Dynamics of HCl",
    "section": "",
    "text": "The main code that runs the simulation is in the src/mol_dyn_md.jl source file. This markdown contians the code to run a simulation using the MolDyn module and wrap the inputs and outputs into a nice format."
  },
  {
    "objectID": "posts/moldyn/index.html#setup-and-run-simulation",
    "href": "posts/moldyn/index.html#setup-and-run-simulation",
    "title": "Julia: Molecular Dynamics of HCl",
    "section": "Setup and Run Simulation",
    "text": "Setup and Run Simulation\n\nDefine Constants\nExpand code block below to see the contants, which include an amu to kg conversion and the number of steps in the simulation.\n\nkg_per_amu = 1.661e-27\nnum_steps = 25000;  # Semicolon to suppress code output from final document\n\n\n\nVectors and matrices holding simulation information.\nExpand the code block below to see the vectors and matrices holding simulation information, including atom velocities, bond connections, energy history and more.\n\n# Positions (xs), velocities (vs), and accelerations (accels) arrays:\n# First axis is timestep\n# Second axis are atoms\n# Third axis is x,y,z (meters for position, m/s for velocities)\n\nvs = zeros(Float64, num_steps, 2, 3)\nxs = zeros(Float64, num_steps, 2, 3)\naccels = zeros(Float64, num_steps, 2, 3)\n\n# Masses: The masses of each atom (kg)\nms = zeros(Float64, 2)\n\n# Total kinetic energies: The total kinetic energy of the system\n# at each timestep.\n\ntkes = zeros(Float64, num_steps)\n\n# Total potential energies: Total potential energy of the system\n# at each timestep\n\ntpes = zeros(Float64, num_steps);  # Semicolon to suppress code output from final document\n\n\n\nInitialize Simulation\nSet the initial conditions of the simulation, including start positions and velocities of the atoms and their masses. Also set up the bonds here.\n\n# Equilibrium bond length for HCl\nr_ab_eq_hcl = 1.57e-10\n\n# Assume Cl is at 0,0,0 and H lies along the x-axis\n\n# HCl equilibrium bond length\nxs[1, 2, :] = [r_ab_eq_hcl*0.999, 0.0, 0.0]\n\n# Masses, Cl first then H\nms[1] = 35 * kg_per_amu\nms[2] = 1 * kg_per_amu\n\n# 1-2 Bonds\n# Rows are bonds, columns are atoms participating in bond\n# Note: This is specifying edges on a graph, so 1-2 also has 2-1\n\none_two_bonds = [1 2; 2 1]\n\n# 1-2 Bonds, stretch constants\n# Note: There is the same constant for each direction of the bond\n# HCl bond constant 516 N/m according to Atkins and de Paula, pg. 454\n\none_two_bonds_kab = [516.0 516.0]\n\n# 1-2 Bonds, equilibrium distances\n# Note: There is a distance for each direction of the bond\n\none_two_bonds_req = [r_ab_eq_hcl r_ab_eq_hcl];  # Semicolon to suppress code output from final document\n\n\n\nFunctions to Run the Simulation\nThe following are all the functions needed to run the velocity verlet trajectory propagation. Code below will use these functions to simulate bond vibration of 1H35Cl.\n\n# Distance from atom a to b\nfunction r_ab(a, b)\n    sqrt(sum((a-b).^2))\nend\n\n# Stretch energy for a 1-2 bond\nfunction stretch_energy(a, b, k_ab, r_ab_eq) \n    0.5*k_ab*(r_ab(a, b)-r_ab_eq)^2\nend\n\n# Kinetic energy for an atom\nfunction kinetic_energy(vs::Array{Float64}, ms::Array{Float64}, timestep, atom)\n    v = vs[timestep, atom, :]\n    m = ms[atom]\n    0.5 * m * sum(v.^2)\nend\n\n# Stretch energy gradient for a single 1-2 bond\nfunction stretch_gradient(a, b, k_ab, r_ab_eq)\n    du_drab = 0.5 * k_ab * (2*r_ab(a, b)-2*r_ab_eq)\n    drab_dxa = (a[1]-b[1])/r_ab(a, b)\n    drab_dya = (a[2]-b[2])/r_ab(a, b)\n    drab_dza = (a[3]-b[3])/r_ab(a, b)\n\n    [drab_dxa, drab_dya, drab_dza] * du_drab\nend\n\n# Propagate 1-2 bond stretch trajectories\nfunction stretch_velocity_verlet(xs, vs, accels, tkes, tpes, one_two_bonds, one_two_bonds_kab, one_two_bonds_req, ms, dt, num_steps)\n    for time_i in 1:num_steps-1\n        for bond_i in [1 2]\n            k_ab = one_two_bonds_kab[bond_i]\n            r_eq = one_two_bonds_req[bond_i]\n            atom_a = one_two_bonds[bond_i, 1]\n            atom_b = one_two_bonds[bond_i, 2]\n            xs[time_i+1, atom_a, :] = xs[time_i, atom_a, :] + vs[time_i, atom_a, :] * dt + accels[time_i, atom_a, :] * dt^2\n            v_mid = vs[time_i, atom_a, :] + 0.5 * accels[time_i, atom_a, :] * dt\n            accels[time_i+1, atom_a, :] = -stretch_gradient(xs[time_i, atom_a, :], xs[time_i, atom_b, :], k_ab, r_eq) / ms[atom_a]\n            vs[time_i+1, atom_a, :] = v_mid + 0.5 * accels[time_i+1, atom_a, :] * dt\n        end\n\n        tkes[time_i] = total_kinetic_energy(vs, ms, time_i)\n        tpes[time_i] = total_stretch_energy(xs, one_two_bonds, one_two_bonds_kab, one_two_bonds_req, time_i)\n    end\n\n    tkes[num_steps] = total_kinetic_energy(vs, ms, num_steps)\n    tpes[num_steps] = total_stretch_energy(xs, one_two_bonds, one_two_bonds_kab, one_two_bonds_req, num_steps)\n\n    return nothing\nend\n\n# Determine the total kinetic energy of the system\nfunction total_kinetic_energy(vs::Array{Float64}, ms::Array{Float64}, timestep::Int)\n    sum([kinetic_energy(vs, ms, timestep, atom) for atom in eachindex(ms)])\nend\n\n# Determine total stretch energy of the system.\nfunction total_stretch_energy(xs::Array{Float64}, one_two_bonds::Array{Int}, one_two_bonds_kab::Array{Float64}, one_two_bonds_req::Array{Float64}, timestep::Int)\n    stretch_energies = zeros(Float64, length(one_two_bonds_kab))\n    \n    for i in eachindex(one_two_bonds_kab)\n        atom_a = one_two_bonds[i, 1]\n        atom_b = one_two_bonds[i, 2]\n        k_ab = one_two_bonds_kab[i]\n        r_eq = one_two_bonds_req[i]\n        pos_a = xs[timestep, atom_a, 1:3]\n        pos_b = xs[timestep, atom_b, 1:3]\n        stretch_energies[i] = stretch_energy(pos_a, pos_b, k_ab, r_eq)\n    end\n\n    # Divide by 2.0 to prevent double counting the 1-2 bonds\n    sum(stretch_energies) / 2.0\nend\n\ntotal_stretch_energy (generic function with 1 method)\n\n\n\n\nVelocity Verlet\nNow for the fun part: Run the simulation! Expand the code block to see the function callt that runs the trajectory with a velocity verlet algorithm.\n\ndt = 1e-18\nstretch_velocity_verlet(xs, vs, accels, tkes, tpes, one_two_bonds, one_two_bonds_kab, one_two_bonds_req, ms, dt, num_steps);  # Semicolon to suppress code output from final document"
  },
  {
    "objectID": "posts/moldyn/index.html#calculate-analytical-period",
    "href": "posts/moldyn/index.html#calculate-analytical-period",
    "title": "Julia: Molecular Dynamics of HCl",
    "section": "Calculate Analytical Period",
    "text": "Calculate Analytical Period\nAs referenced above and as a check of the simulation, calculate the analytical period of the oscillation of the 1H35Cl bond. Units are in seconds.\n\nμ = 1/(1/ms[1]+1/ms[2])\n2π * sqrt(μ/one_two_bonds_kab[1])\n\n1.1115336262465321e-14"
  },
  {
    "objectID": "posts/moldyn/index.html#make-plots",
    "href": "posts/moldyn/index.html#make-plots",
    "title": "Julia: Molecular Dynamics of HCl",
    "section": "Make Plots",
    "text": "Make Plots\n\nX-Coordinate of Hydrogen\nPlot the x-coordinate of the hydrogen. Notice that the period on the plot agrees with analytical period!\n\nx_axis = eachindex(xs[:, 2, 1]) / 1000\nh_x_axis_trajectory = xs[:, 2, 1]\nhydrogen_plot = plot(x_axis, h_x_axis_trajectory, xlabel=\"Time (fs)\", ylabel=\"H x position (m)\", legend=false)\ndisplay(hydrogen_plot)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTotal Energy\nPlot the kinetic, potential, and total energy of the system.\n\nplot(x_axis, tkes, xlabel=\"Time (fs)\", ylabel=\"J\", label=\"Ek\")\nplot!(x_axis, tpes, label=\"Ep\")\nenergy_plot = plot!(x_axis, tpes + tkes, label=\"total\")\ndisplay(energy_plot)\n\n┌ Warning: No strict ticks found\n└ @ PlotUtils ~/.julia/packages/PlotUtils/jEGKP/src/ticks.jl:191\n┌ Warning: No strict ticks found\n└ @ PlotUtils ~/.julia/packages/PlotUtils/jEGKP/src/ticks.jl:191\n┌ Warning: No strict ticks found\n└ @ PlotUtils ~/.julia/packages/PlotUtils/jEGKP/src/ticks.jl:191\n┌ Warning: No strict ticks found\n└ @ PlotUtils ~/.julia/packages/PlotUtils/jEGKP/src/ticks.jl:191\n┌ Warning: No strict ticks found\n└ @ PlotUtils ~/.julia/packages/PlotUtils/jEGKP/src/ticks.jl:191\n┌ Warning: No strict ticks found\n└ @ PlotUtils ~/.julia/packages/PlotUtils/jEGKP/src/ticks.jl:191\n┌ Warning: No strict ticks found\n└ @ PlotUtils ~/.julia/packages/PlotUtils/jEGKP/src/ticks.jl:191"
  },
  {
    "objectID": "posts/simple-gradient-descent/index.html",
    "href": "posts/simple-gradient-descent/index.html",
    "title": "Python: Simple Gradient Descent",
    "section": "",
    "text": "This is a simple polynomial gradient descent. It is a naive implmentation that is not optimized or vectorized. It is meant to be a simple demo on how gradient descent can be accomplished. To keep it simple, it uses base Python. I don’t intend for it to be used for anything important!\n\n\nThe “target” polynomial that will be fitted is defined as Eqn. 1:\n\\[ y_i = \\sum_{i=0}^{n} a_i x^i \\]\nThe “estimate” polynomial that will be fitted is defined the same way but with a hat of the y Eqn. 2:\n\\[ \\hat y_i = \\sum_{i=0}^{n} a_i x^i \\]\nTo fit the polynomial the code will minimize the residual sum of squares (RSS) function Eqn. 3:\n\\[ RSS = \\sum_{i=0}^{n} (y_i - \\hat y_i)^2 \\]\nGradient desscent needs the partial derivative of the RSS with respect to each ceofficient, which is Eqn. 4:\n\\[ {\\partial \\over \\partial a_k}  = -2 \\sum_{i=1}^n \\left(y_i-\\hat y_i\\right) x_i^{k} \\]\nTo define each polynomial, I will gather the coefficients into a vector Eqn. 5:\n\\[ \\mathbf a = [a_1, a_2, ..., a_i] \\]\n\n\n\nThe code in this example is built around functions, so I will define these functions in the first part of the notebook and use these functions in the second part of the notebook.\n\n\nSince I am not using numpy, I am making my own linspace function. Later, this function will make the x-axis to evaluate the polynomials with.\n\ndef linspace(min_val, max_val, npoints):\n    \"\"\"\n    Creates a list of floating point values between the minimum and\n    maximum values, with the number of points (+1) to cover the entire\n    span specified.\n    \n    Parameters\n    ----------\n    min_val\n        The minimum value in the range as a float.\n        \n    max_val\n        The maximum value in the range as a float.\n        \n    npoints\n        The number of points in the range as a float.\n        \n    Returns\n    -------\n    list[float]\n        A list of floating point values as specified.\n    \"\"\"\n    \n    return [min_val+(max_val-min_val)/npoints*i for i in range(npoints+1)]\n\n\n\n\nThis will evaluate a list of y values from a polynomial according to Eqns 1 and 2 with an x-axis and vector of coefficients.\n\ndef polynomial(x_axis, coeffs):\n    \"\"\"\n    Evaluates a polynomial along a given axis given coefficients.\n    \n    Parameters\n    ----------\n    x_axis:\n         A list of floats that is the x-axis to supply as x_i.\n         \n    coeffs:\n        The coefficients of the polynomial as defined in the vector\n        in Eqn. 4.\n        \n    Returns\n    -------\n    list[float]\n        Returns a list of floats that are the values of the polynomial.\n    \"\"\"\n    \n    ys = []\n    for x in x_axis:\n        y = 0.\n        for i, coeff in enumerate(coeffs):\n            y += coeff * x**i\n        ys.append(y)\n    return ys\n\n\n\n\nThis function will calculate the error between the target and estimate polynomials according to Eqn. 3.\n\ndef rss(x_axis, y_coeffs, y_hat_coeffs):\n    \"\"\"\n    Calculates the RSS as defined in Eqn 3 between the two polynomials \n    specified in Eqns 1 or 2.\n    \n    Parameters\n    ----------\n    x_axis\n        The x-axis as a list of floats with which to compare the \n        polynomials.\n        \n    y_coeffs:\n        The coefficients as a list of floats for the target polynomial.\n        \n    y_hat_coeffs\n        The coefficients as a list of floats for the estimate polynomial.\n        \n    Returns\n    -------\n    float\n        An RSS value between the target and estimate.\n    \"\"\"\n    \n    target_ys = polynomial(x_axis, y_coeffs)\n    estimate_ys = polynomial(x_axis, y_hat_coeffs)\n    return sum((target_y - estimate_y)**2 for target_y, estimate_y in zip(target_ys, estimate_ys))\n\n\n\n\nThis function calculates the components of the gradient of the RSS error between the target and estimate coefficients. It implements Eqn 4.\n\ndef gradient(x_axis, target_ys, estimate_ys, y_hat_coeffs):\n    \"\"\"\n    Calculates the gradient of the error between the target and estimate\n    polynomials and returns the components of the gradient in a list of\n    floats.\n    \n    Parameters\n    ----------\n    x_axis\n        The x axis as a list of floats.\n    \n    target_ys\n        List of floats that is the target polynomial y values.\n        \n    estimate_ys\n        List of floats that is the estimate polynomial y values.\n        \n    y_hat_coeffs\n        The estimate coefficients as a list of floats.\n        \n    Returns\n    -------\n    list[float]\n        The components of the gradient as a list of floats.\n    \"\"\"\n    \n    components = []\n    for k, _ in enumerate(y_hat_coeffs):\n        component = 0.\n        for i, (target_y, estimate_y) in enumerate(zip(target_ys, estimate_ys)):\n            component += (target_y - estimate_y) * x_axis[i] ** k\n        components.append(-2 * component)\n    return components\n\n\n\n\nThis function uses the gradient to iteravely refine the estimate coefficients to move the estimate closer to the target. It returns the history of the RSS values along the way.\n\ndef gradient_descent(x_axis, target_ys, target_coeffs, y_hat_coeffs_initial, learn_rate=1e-6, max_iter=1000, rss_threshold=50.):\n    \"\"\"\n    Performs gradient descent optimization to make the estimate coefficients\n    converge to values that give a polynomial function with a shape similar\n    to the target values.\n    \n    Training continues until max iterations are reached or the RSS diminishes\n    below the given threshold.\n    \n    Parameters\n    ----------\n    x_axis\n        List of floats that is the x-axis for the polynomials.\n        \n    target_ys\n        List of floats that is the target polynomial.\n        \n    y_hat_coeffs_initial\n        The initial guess for the estimate coefficients\n        \n    learn_rate\n        The rate at which to descend the gradient during fitting. Higher numbers\n        descend quicker but may not find the true minimum.\n        \n    max_iter\n        Integer of the maximum number of iterations the algorithm will attempt.\n        Used to prevent infinite loops.\n        \n    rss_threshold\n        If RSS diminishes below this threshold, training iterations will stop.\n        \n    Returns\n    -------\n    list[dict]\n        A list of dictionaries containing the training history at each iteration.\n    \"\"\"\n    \n    fit_history = []\n    y_hat_coeffs = y_hat_coeffs_initial[:]\n    for i in range(max_iter):\n        estimate_ys = polynomial(x_axis, y_hat_coeffs)\n        estimate_rss = rss(x_axis, target_coeffs, y_hat_coeffs)\n        fit_history.append({\n            'rss': estimate_rss,\n            'y_hat_coeffs': y_hat_coeffs[:]\n        })\n        if estimate_rss &lt; rss_threshold:\n            break\n        current_gradient = gradient(x_axis, target_ys, estimate_ys, y_hat_coeffs)\n        y_hat_coeffs = [y_hat_coeff-learn_rate*gi for y_hat_coeff, gi in zip(y_hat_coeffs, current_gradient)]\n    return fit_history\n\n\n\n\n\n\n\n\ncommon_x_axis = linspace(-5., 5., 100)\n\n\n\n\nThe target polynomial will be defined by a vector called target_coeffs. The coefficients for the initial estimated coefficients will be estimate_coeffs. target_coeffs will not change since they represent the truth in the estimate polynomial. The estiamte_coeffs will be iteratively updated as the estimate moves closer to the target.\n\ntarget_coeffs = [-2.0, 0.0, 2.5, 1.2]\nestimate_coeffs = [-2.5, 0.0, 2.0, -1.7]\n\n\n\n\n\n\n\nFor the remainder of this notebook, the target polynomial will be in blue and the estimate polynomial will be in orange. I will include the initial RSS in the title.\n\ntarget_0 = polynomial(common_x_axis, target_coeffs)\nestimate_0 = polynomial(common_x_axis, estimate_coeffs)\nfig, ax = plt.subplots(nrows=1, ncols=1)\nax.scatter(common_x_axis, target_0, color='blue', alpha=0.6, label='target')\nax.scatter(common_x_axis, estimate_0, color='orange', alpha=0.6, label='estimate')\nax.legend()\n\n\n\n\n\n\n\n\nAs a reminder, here are the target coefficients and the initial estimate coefficients:\n\nprint(f'Target coefficients {target_coeffs}')\nprint(f'Initial estimate coefficients {estimate_coeffs}')\nprint(f'Initial RSS {rss(common_x_axis, target_coeffs, estimate_coeffs)}')\n\nTarget coefficients [-2.0, 0.0, 2.5, 1.2]\nInitial estimate coefficients [-2.5, 0.0, 2.0, -1.7]\nInitial RSS 2015004.0007105004\n\n\n\n\n\n\ngradient_descent_history = gradient_descent(common_x_axis, target_0, target_coeffs, estimate_coeffs)\n\n\n\n\nAs gradient descent fits the estimate coefficients, the RSS should drop with each iteration.\n\nrss_history = [step['rss'] for step in gradient_descent_history]\nfig, ax = plt.subplots(nrows=1, ncols=1)\nax.set_yscale('log')\nax.plot(list(range(len(rss_history))), rss_history, color='green')\nax.set_title(f'RSS vs Iteration')\nax.set_ylabel('RSS')\nax.set_xlabel('iteration')\n\nText(0.5, 0, 'iteration')\n\n\n\n\n\n\n\n\n\n\n\n\nThis is a graphical representation of how close the fit is after training.\n\nestimate_final = polynomial(common_x_axis, gradient_descent_history[-1]['y_hat_coeffs'])\nfig, ax = plt.subplots(nrows=1, ncols=1)\nax.scatter(common_x_axis, target_0, color='blue', alpha=0.6, label='target')\nax.scatter(common_x_axis, estimate_final, color='orange', alpha=0.6, label='estimate')\nax.legend()\n\n\n\n\n\n\n\n\n\n\n\nThese are the numeric results of the training.\n\nfinal_estimate_coeffs = gradient_descent_history[-1]['y_hat_coeffs']\ninitial_rss = gradient_descent_history[0]['rss']\nprint(f'Training iterations {len(gradient_descent_history)}')\nprint(f'Target coefficients {target_coeffs}')\nprint(f'Final estimate coefficients {final_estimate_coeffs}')\nprint(f'Initial RSS {initial_rss}')\nprint(f'Final RSS {rss(common_x_axis, target_coeffs, final_estimate_coeffs)}')\n\nTraining iterations 88\nTarget coefficients [-2.0, 0.0, 2.5, 1.2]\nFinal estimate coefficients [-2.4649992311439837, 0.1551299749689758, 2.4784435198598582, 1.1914759552905416]\nInitial RSS 2015004.0007105004\nFinal RSS 48.45559484188128\n\n\n\n\n\n\n\nGöbel, Börge. Computational Physics, Section 3.\nJames, Gareth et al. An Introduction to Statistical Learning with Applications in R, Eqn 3.16."
  },
  {
    "objectID": "posts/simple-gradient-descent/index.html#some-equations",
    "href": "posts/simple-gradient-descent/index.html#some-equations",
    "title": "Python: Simple Gradient Descent",
    "section": "",
    "text": "The “target” polynomial that will be fitted is defined as Eqn. 1:\n\\[ y_i = \\sum_{i=0}^{n} a_i x^i \\]\nThe “estimate” polynomial that will be fitted is defined the same way but with a hat of the y Eqn. 2:\n\\[ \\hat y_i = \\sum_{i=0}^{n} a_i x^i \\]\nTo fit the polynomial the code will minimize the residual sum of squares (RSS) function Eqn. 3:\n\\[ RSS = \\sum_{i=0}^{n} (y_i - \\hat y_i)^2 \\]\nGradient desscent needs the partial derivative of the RSS with respect to each ceofficient, which is Eqn. 4:\n\\[ {\\partial \\over \\partial a_k}  = -2 \\sum_{i=1}^n \\left(y_i-\\hat y_i\\right) x_i^{k} \\]\nTo define each polynomial, I will gather the coefficients into a vector Eqn. 5:\n\\[ \\mathbf a = [a_1, a_2, ..., a_i] \\]"
  },
  {
    "objectID": "posts/simple-gradient-descent/index.html#custom-functions",
    "href": "posts/simple-gradient-descent/index.html#custom-functions",
    "title": "Python: Simple Gradient Descent",
    "section": "",
    "text": "The code in this example is built around functions, so I will define these functions in the first part of the notebook and use these functions in the second part of the notebook.\n\n\nSince I am not using numpy, I am making my own linspace function. Later, this function will make the x-axis to evaluate the polynomials with.\n\ndef linspace(min_val, max_val, npoints):\n    \"\"\"\n    Creates a list of floating point values between the minimum and\n    maximum values, with the number of points (+1) to cover the entire\n    span specified.\n    \n    Parameters\n    ----------\n    min_val\n        The minimum value in the range as a float.\n        \n    max_val\n        The maximum value in the range as a float.\n        \n    npoints\n        The number of points in the range as a float.\n        \n    Returns\n    -------\n    list[float]\n        A list of floating point values as specified.\n    \"\"\"\n    \n    return [min_val+(max_val-min_val)/npoints*i for i in range(npoints+1)]\n\n\n\n\nThis will evaluate a list of y values from a polynomial according to Eqns 1 and 2 with an x-axis and vector of coefficients.\n\ndef polynomial(x_axis, coeffs):\n    \"\"\"\n    Evaluates a polynomial along a given axis given coefficients.\n    \n    Parameters\n    ----------\n    x_axis:\n         A list of floats that is the x-axis to supply as x_i.\n         \n    coeffs:\n        The coefficients of the polynomial as defined in the vector\n        in Eqn. 4.\n        \n    Returns\n    -------\n    list[float]\n        Returns a list of floats that are the values of the polynomial.\n    \"\"\"\n    \n    ys = []\n    for x in x_axis:\n        y = 0.\n        for i, coeff in enumerate(coeffs):\n            y += coeff * x**i\n        ys.append(y)\n    return ys\n\n\n\n\nThis function will calculate the error between the target and estimate polynomials according to Eqn. 3.\n\ndef rss(x_axis, y_coeffs, y_hat_coeffs):\n    \"\"\"\n    Calculates the RSS as defined in Eqn 3 between the two polynomials \n    specified in Eqns 1 or 2.\n    \n    Parameters\n    ----------\n    x_axis\n        The x-axis as a list of floats with which to compare the \n        polynomials.\n        \n    y_coeffs:\n        The coefficients as a list of floats for the target polynomial.\n        \n    y_hat_coeffs\n        The coefficients as a list of floats for the estimate polynomial.\n        \n    Returns\n    -------\n    float\n        An RSS value between the target and estimate.\n    \"\"\"\n    \n    target_ys = polynomial(x_axis, y_coeffs)\n    estimate_ys = polynomial(x_axis, y_hat_coeffs)\n    return sum((target_y - estimate_y)**2 for target_y, estimate_y in zip(target_ys, estimate_ys))\n\n\n\n\nThis function calculates the components of the gradient of the RSS error between the target and estimate coefficients. It implements Eqn 4.\n\ndef gradient(x_axis, target_ys, estimate_ys, y_hat_coeffs):\n    \"\"\"\n    Calculates the gradient of the error between the target and estimate\n    polynomials and returns the components of the gradient in a list of\n    floats.\n    \n    Parameters\n    ----------\n    x_axis\n        The x axis as a list of floats.\n    \n    target_ys\n        List of floats that is the target polynomial y values.\n        \n    estimate_ys\n        List of floats that is the estimate polynomial y values.\n        \n    y_hat_coeffs\n        The estimate coefficients as a list of floats.\n        \n    Returns\n    -------\n    list[float]\n        The components of the gradient as a list of floats.\n    \"\"\"\n    \n    components = []\n    for k, _ in enumerate(y_hat_coeffs):\n        component = 0.\n        for i, (target_y, estimate_y) in enumerate(zip(target_ys, estimate_ys)):\n            component += (target_y - estimate_y) * x_axis[i] ** k\n        components.append(-2 * component)\n    return components\n\n\n\n\nThis function uses the gradient to iteravely refine the estimate coefficients to move the estimate closer to the target. It returns the history of the RSS values along the way.\n\ndef gradient_descent(x_axis, target_ys, target_coeffs, y_hat_coeffs_initial, learn_rate=1e-6, max_iter=1000, rss_threshold=50.):\n    \"\"\"\n    Performs gradient descent optimization to make the estimate coefficients\n    converge to values that give a polynomial function with a shape similar\n    to the target values.\n    \n    Training continues until max iterations are reached or the RSS diminishes\n    below the given threshold.\n    \n    Parameters\n    ----------\n    x_axis\n        List of floats that is the x-axis for the polynomials.\n        \n    target_ys\n        List of floats that is the target polynomial.\n        \n    y_hat_coeffs_initial\n        The initial guess for the estimate coefficients\n        \n    learn_rate\n        The rate at which to descend the gradient during fitting. Higher numbers\n        descend quicker but may not find the true minimum.\n        \n    max_iter\n        Integer of the maximum number of iterations the algorithm will attempt.\n        Used to prevent infinite loops.\n        \n    rss_threshold\n        If RSS diminishes below this threshold, training iterations will stop.\n        \n    Returns\n    -------\n    list[dict]\n        A list of dictionaries containing the training history at each iteration.\n    \"\"\"\n    \n    fit_history = []\n    y_hat_coeffs = y_hat_coeffs_initial[:]\n    for i in range(max_iter):\n        estimate_ys = polynomial(x_axis, y_hat_coeffs)\n        estimate_rss = rss(x_axis, target_coeffs, y_hat_coeffs)\n        fit_history.append({\n            'rss': estimate_rss,\n            'y_hat_coeffs': y_hat_coeffs[:]\n        })\n        if estimate_rss &lt; rss_threshold:\n            break\n        current_gradient = gradient(x_axis, target_ys, estimate_ys, y_hat_coeffs)\n        y_hat_coeffs = [y_hat_coeff-learn_rate*gi for y_hat_coeff, gi in zip(y_hat_coeffs, current_gradient)]\n    return fit_history"
  },
  {
    "objectID": "posts/simple-gradient-descent/index.html#define-the-target-and-estimate-polynomials",
    "href": "posts/simple-gradient-descent/index.html#define-the-target-and-estimate-polynomials",
    "title": "Python: Simple Gradient Descent",
    "section": "",
    "text": "common_x_axis = linspace(-5., 5., 100)\n\n\n\n\nThe target polynomial will be defined by a vector called target_coeffs. The coefficients for the initial estimated coefficients will be estimate_coeffs. target_coeffs will not change since they represent the truth in the estimate polynomial. The estiamte_coeffs will be iteratively updated as the estimate moves closer to the target.\n\ntarget_coeffs = [-2.0, 0.0, 2.5, 1.2]\nestimate_coeffs = [-2.5, 0.0, 2.0, -1.7]"
  },
  {
    "objectID": "posts/simple-gradient-descent/index.html#fitting-the-polynomial",
    "href": "posts/simple-gradient-descent/index.html#fitting-the-polynomial",
    "title": "Python: Simple Gradient Descent",
    "section": "",
    "text": "For the remainder of this notebook, the target polynomial will be in blue and the estimate polynomial will be in orange. I will include the initial RSS in the title.\n\ntarget_0 = polynomial(common_x_axis, target_coeffs)\nestimate_0 = polynomial(common_x_axis, estimate_coeffs)\nfig, ax = plt.subplots(nrows=1, ncols=1)\nax.scatter(common_x_axis, target_0, color='blue', alpha=0.6, label='target')\nax.scatter(common_x_axis, estimate_0, color='orange', alpha=0.6, label='estimate')\nax.legend()\n\n\n\n\n\n\n\n\nAs a reminder, here are the target coefficients and the initial estimate coefficients:\n\nprint(f'Target coefficients {target_coeffs}')\nprint(f'Initial estimate coefficients {estimate_coeffs}')\nprint(f'Initial RSS {rss(common_x_axis, target_coeffs, estimate_coeffs)}')\n\nTarget coefficients [-2.0, 0.0, 2.5, 1.2]\nInitial estimate coefficients [-2.5, 0.0, 2.0, -1.7]\nInitial RSS 2015004.0007105004\n\n\n\n\n\n\ngradient_descent_history = gradient_descent(common_x_axis, target_0, target_coeffs, estimate_coeffs)\n\n\n\n\nAs gradient descent fits the estimate coefficients, the RSS should drop with each iteration.\n\nrss_history = [step['rss'] for step in gradient_descent_history]\nfig, ax = plt.subplots(nrows=1, ncols=1)\nax.set_yscale('log')\nax.plot(list(range(len(rss_history))), rss_history, color='green')\nax.set_title(f'RSS vs Iteration')\nax.set_ylabel('RSS')\nax.set_xlabel('iteration')\n\nText(0.5, 0, 'iteration')\n\n\n\n\n\n\n\n\n\n\n\n\nThis is a graphical representation of how close the fit is after training.\n\nestimate_final = polynomial(common_x_axis, gradient_descent_history[-1]['y_hat_coeffs'])\nfig, ax = plt.subplots(nrows=1, ncols=1)\nax.scatter(common_x_axis, target_0, color='blue', alpha=0.6, label='target')\nax.scatter(common_x_axis, estimate_final, color='orange', alpha=0.6, label='estimate')\nax.legend()\n\n\n\n\n\n\n\n\n\n\n\nThese are the numeric results of the training.\n\nfinal_estimate_coeffs = gradient_descent_history[-1]['y_hat_coeffs']\ninitial_rss = gradient_descent_history[0]['rss']\nprint(f'Training iterations {len(gradient_descent_history)}')\nprint(f'Target coefficients {target_coeffs}')\nprint(f'Final estimate coefficients {final_estimate_coeffs}')\nprint(f'Initial RSS {initial_rss}')\nprint(f'Final RSS {rss(common_x_axis, target_coeffs, final_estimate_coeffs)}')\n\nTraining iterations 88\nTarget coefficients [-2.0, 0.0, 2.5, 1.2]\nFinal estimate coefficients [-2.4649992311439837, 0.1551299749689758, 2.4784435198598582, 1.1914759552905416]\nInitial RSS 2015004.0007105004\nFinal RSS 48.45559484188128"
  },
  {
    "objectID": "posts/simple-gradient-descent/index.html#references",
    "href": "posts/simple-gradient-descent/index.html#references",
    "title": "Python: Simple Gradient Descent",
    "section": "",
    "text": "Göbel, Börge. Computational Physics, Section 3.\nJames, Gareth et al. An Introduction to Statistical Learning with Applications in R, Eqn 3.16."
  },
  {
    "objectID": "posts/fftpipe/index.html",
    "href": "posts/fftpipe/index.html",
    "title": "R: FFT with fftpipe",
    "section": "",
    "text": "fftpipe is a package of functions that wrap around the base R fft() function. The fftpipe package enables workflows around the fft() function that use the pipe (%&gt;%) operator. I took inspiration for the interface to fftpipe from the Tidyverse and tidymodels packages.\nSpecifically, fftpipe offers the following functionality:\n\nWaveform generation,\nFFT and inverse FFT transformation,\nPlotting of these waveforms and FFTs."
  },
  {
    "objectID": "posts/fftpipe/index.html#what-is-fftpipe",
    "href": "posts/fftpipe/index.html#what-is-fftpipe",
    "title": "R: FFT with fftpipe",
    "section": "",
    "text": "fftpipe is a package of functions that wrap around the base R fft() function. The fftpipe package enables workflows around the fft() function that use the pipe (%&gt;%) operator. I took inspiration for the interface to fftpipe from the Tidyverse and tidymodels packages.\nSpecifically, fftpipe offers the following functionality:\n\nWaveform generation,\nFFT and inverse FFT transformation,\nPlotting of these waveforms and FFTs."
  },
  {
    "objectID": "posts/fftpipe/index.html#installation",
    "href": "posts/fftpipe/index.html#installation",
    "title": "R: FFT with fftpipe",
    "section": "Installation",
    "text": "Installation\nInstall fftpipe from GitHub with devtools. If you don’t have devtools installed already, install it with install.packages(\"devtools\"). Once devtools is installed, you can then install fftpipe by typing the following command into the R console:\ndevtools::install_github(\"akey7/fftpipe\")"
  },
  {
    "objectID": "posts/fftpipe/index.html#quick-start",
    "href": "posts/fftpipe/index.html#quick-start",
    "title": "R: FFT with fftpipe",
    "section": "Quick Start",
    "text": "Quick Start\nMore detail about each of these steps is described below in this document. But this will get you started!\n\nLoad the necessary packages\nWhile you can use fftpipe on its own, it is designed to work within the Tidyverse ecosystem, so I recommend you load the tidyverse as well. Also, I will set a theme for ggplot().\n\nsuppressPackageStartupMessages(library(fftpipe))\nsuppressPackageStartupMessages(library(tidyverse))\ntheme_set(theme_linedraw(base_size = 15))\n\n\n\nGenerate a waveform\nWaveforms can either be built from external data or synthesized from within the fftpipe package. For this quick start demo, let’s compose a waveform to feed into the FFT with the following properties:\n\nIts duration will be 1 second with a sample rate of 200 samples/second.\nIt will be the sum of 2 cosines, with the second cosine being 3x the frequency and 50% the amplitude of the first cosine.\nIts total amplitude will decrease with an exponential decay function, with an exponential time constant (tau) of 0.5.\nThe final result will be normalized by dividing the vector of values by the length of that vector to prepare the waveform for FFT.\n\nWe can compose this waveform using functions from fftpipe as shown in this code block:\n\nwv &lt;- waveform(duration_s = 1.0, sr = 100) %&gt;%\n  cos_sum(freqs = c(2.0, 6.0), amplitudes = c(1.0, 0.9)) %&gt;%\n  length_norm()\n\n\n\nPlot the input waveform\nWe can streamline plotting the input waveform with the following function call. This plot can be refined in ways I’ll describe later in the document.\n\nwaveform_plot(wv)\n\n\n\n\n\n\n\n\n\n\nPerform the FFT\nWe can perform an FFT on the waveform we just made. To do that, run the following line:\n\nwv_fft &lt;- wv %&gt;%\n  compute_fft()\n\nWe can then use this FFT data.frame to plot the FFT and reconstruct the original waveform in the next two steps.\n\n\nPlot the FFT\nfft_plot() plots the FFT as shown below. By default, the plot only shows the frequency components that are at or below the Nyquist frequency (half the sample rate). Here, our sample rate is 100 Hz, so the maximum frequency is 50 Hz. This plot can be further customized, which will be shown later in the document.\nNote how our original component cosines we summed together appear here as peaks at 2 Hz and 6 Hz. The first peak is taller than the second peak, which corresponds to our 6 Hz component having less amplitude than the 2 Hz component. Hence, our FFT captured the frequencies of our original waveform!\n\nwv_fft %&gt;%\n  fft_plot()\n\n\n\n\n\n\n\n\n\n\nReconstruct the original waveform from the FFT\nFinally, we can reconstruct the original waveform from the FFT. First, we need to make a waveform that defines the sample rate and values for the waveform to be reconstructed. This should match the waveform() call above. Then we need to feed both the new waveform and FFT into the inverse_FFT(). Then, we can pass the reconstruction through a length_norm() call and plot the reconstructed waveform.\n\nwaveform(duration_s = 1.0, sr = 100) %&gt;%\n  inverse_fft(wv_fft) %&gt;%\n  length_norm() %&gt;%\n  waveform_plot()\n\n\n\n\n\n\n\n\nBy using length_norm() before and after the FFT, the amplitudes of our waveform are the same before and after the FFT."
  },
  {
    "objectID": "posts/fftpipe/index.html#in-depth",
    "href": "posts/fftpipe/index.html#in-depth",
    "title": "R: FFT with fftpipe",
    "section": "In Depth",
    "text": "In Depth\nIn this section, I will go over the capabilities of the fftpipe package in more detail. This section will cover:\n\nfftpipe is built around dataframes.\nHow do you customize plots made with waveform_plot() and fft_plot()?\nHow do you compose a waveform with waveform(), cos_sum(), exp_decay(), white_noise(), and length_norm()?\nHow do you do FFT operations with compute_fft() and inverse_fft(). What options are available for fft_plot()?\nHow do you do signal denoising with denoise_fft()?\n\nYou can read the source code for all the functions on GitHub\n\nfftpipe Is Built Around Dataframes\nfftpipe functions pass data frames to each other with the pipe (%&gt;%) operator. The columns differ depending on if a dataframe represents an FFT or a waveform. A waveform is what you pass into an FFT or get out of an inverse FFT.\nWaveform dataframes contain the following columns:\n\n\n\nColumn\nPurpose\n\n\n\n\n.sample\nAn index of the sample in waveform the row represents.\n\n\n.sec\nt: Time of that row in the waveform.\n\n\n.value\nf(t): Value of the waveform at that time.\n\n\n\nFFT dataframes contain the following columns:\n\n\n\n\n\n\n\nColumn\nPurpose\n\n\n\n\n.idx\nIndex of the coefficient. Used to compute the frequency of each coefficient.\n\n\n.value\nThe complex value of the Fourier coefficient.\n\n\n.psd\nThe power spectral density of that Fourier coefficient.\n\n\n\nBy passing these values around in dataframes, the functions of fftpipe can share data amongst themselves without needing the same information specified repeatedly in code.\n\n\nHow Do You Customize Plots?\nThe plots above showed some information but they were not great. The axes didn’t have descriptive labels and the plots lacked titles. Also, the theme was a bit drab. Let’s fix that!\nThe plots created by waveform_plot() and fft_plot() are simply ggplot objects that can be displayed or saved as you wish. Both waveform_plot() and fft_plot() accept ... arguments which are passed directly to the labs() function. Let’s generate a new waveform and then customize its plot\n(You will see some new functions when we create the waveform; these will be explained later.)\n\nwv_to_customize &lt;- waveform(duration_s = 1.0, sr = 200) %&gt;%\n  cos_sum(\n    freqs = c(5, 10, 20), \n    amplitudes = c(1.0, 0.875, 0.75), \n    phases = c(3*pi/2, 0, pi/2)\n  ) %&gt;%\n  exp_decay(decay_tau = 0.5) %&gt;%\n  length_norm()\n\nwv_to_customize %&gt;%\n  waveform_plot()\n\n\n\n\n\n\n\n\nSince waveform_plot() and fft_plot() accept arguments to pass to label(), we can add labels to this plot. In your plots, you don’t need to specify all the labels, but I’ve put them all in here to demonstrate what you can do.\n\nwv_to_customize %&gt;%\n  waveform_plot(\n    title = \"My Favorite Waveform!\",\n    subtitle = \"Let's Customize This Plot.\",\n    caption = \"Generated completely with fftpipe\",\n    x = \"t (s)\",\n    y = \"f(t)\"\n  )\n\n\n\n\n\n\n\n\nSince this is just a ggplot object, we can add themeing:\n\nwv_to_customize %&gt;%\n  waveform_plot(\n    title = \"My Favorite Waveform!\",\n    subtitle = \"Let's Customize This Plot.\",\n    caption = \"Generated completely with fftpipe\",\n    x = \"t (s)\",\n    y = \"f(t)\"\n  ) +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.caption = element_text(colour = \"blue\", face = \"bold\")\n  )\n\n\n\n\n\n\n\n\nFor theming, the sky is the limit here. Go for it!\n\n\nHow Do You Compose a Waveform for Testing?\nHow do the functions waveform(), cos_sum(), exp_decay(), white_noise(), and length_norm() work together to make waveforms for testing? Let’s illustrate this with an example where we build operations up to make the example waveform shown in the plots above.\nwaveform() creates the primary attributes of a waveform: a duration in seconds and a sample rate. It also fills the values of the waveform with zero to enable further addition operations. Here, I define a waveform that is one second long with a sample rate of 200 Hz.\n\nwv_to_customize &lt;- waveform(duration_s = 1.0, sr = 200)\n\nwv_to_customize %&gt;%\n  waveform_plot()\n\n\n\n\n\n\n\n\nNow the waveform needs something. That is what cos_sum() is for. cos_sum() takes vectors of frequencies, amplitudes, and phases of cos() functions to sum into a final waveform. It sums them up and adds them to the incoming waveform which is specified by the first argument to the function:\n\nwv_to_customize &lt;- waveform(duration_s = 1.0, sr = 200) %&gt;%\n  cos_sum(\n    freqs = c(5, 10, 20), \n    amplitudes = c(1.0, 0.875, 0.75), \n    phases = c(3*pi/2, 0, pi/2)\n  )\n\nwv_to_customize %&gt;%\n  waveform_plot(x = \"t (s)\", y = \"f(t)\")\n\n\n\n\n\n\n\n\nNow we have a waveform we can do something with. But there is still more that we can do!\nWe can add noise to the signal with white_noise(). Speicifcally, this function adds random numbers drawn from a normal distribution into the incoming waveform. It takes two arguments, both of which are optional: mean and sd. Adjusting sd is like adjusting the amplitude of the noise (lower values are less noise).\n\nwv_to_customize &lt;- waveform(duration_s = 1.0, sr = 200) %&gt;%\n  cos_sum(\n    freqs = c(5, 10, 20), \n    amplitudes = c(1.0, 0.875, 0.75), \n    phases = c(3*pi/2, 0, pi/2)\n  ) %&gt;%\n  white_noise(mean = 0, sd = 1e-5)\n\nwv_to_customize %&gt;%\n  waveform_plot(x = \"t (s)\", y = \"f(t)\")\n\n\n\n\n\n\n\n\nWe can multiply by an exponential decay to create a waveform whose amplitude diminishes over time with exp_decay(). In addition to an incoming dataframe which specifies a waveform, exp_decay() accepts one other parameter decay_tau which specifies the rate of decay (lower values mean faster decay rate).\n\nwv_to_customize &lt;- waveform(duration_s = 1.0, sr = 200) %&gt;%\n  cos_sum(\n    freqs = c(5, 10, 20), \n    amplitudes = c(1.0, 0.875, 0.75), \n    phases = c(3*pi/2, 0, pi/2)\n  ) %&gt;%\n  white_noise(mean = 0, sd = 1e-5) %&gt;%\n  exp_decay(decay_tau = 0.5)\n\nwv_to_customize %&gt;%\n  waveform_plot(x = \"t (s)\", y = \"f(t)\")\n\n\n\n\n\n\n\n\nFinally, it’s good to normalize the waveform after creating it before applying a Fourier transform. A common technique I have seen is to divide each element of the signal’s vector by the length of the vector. This functionality is accomplished by the length_norm() function. Note how the amplitude drops in the following plot compared to the plots above.\n\nwv_to_customize &lt;- waveform(duration_s = 1.0, sr = 200) %&gt;%\n  cos_sum(\n    freqs = c(5, 10, 20), \n    amplitudes = c(1.0, 0.875, 0.75), \n    phases = c(3*pi/2, 0, pi/2)\n  ) %&gt;%\n  white_noise(mean = 0, sd = 1e-5) %&gt;%\n  exp_decay(decay_tau = 0.5) %&gt;%\n  length_norm()\n\nwv_to_customize %&gt;%\n  waveform_plot(x = \"t (s)\", y = \"f(t)\")\n\n\n\n\n\n\n\n\nAll the steps except the waveform() creation are optional. Mix and match to your heart’s content!\n\n\nHow Do You Do FFT Operations?\ncompute_fft() and inverse_fft() perform fast fouriere transform (FFT) operations and the results can be plotted with fft_plot(). Fourier transforms, Fourier series, and Fourier analysis are HUGE topics that span many areas of math and physics. I won’t go into those applications here. But I will show you how to use these functions as fundamental building blocks as a starting point for more advanced FFT applications.\nLet’s revisit our most recent waveform we generated:\n\nwv_for_fft &lt;- waveform(duration_s = 1.0, sr = 200) %&gt;%\n  cos_sum(\n    freqs = c(5, 10, 20), \n    amplitudes = c(1.0, 0.875, 0.75), \n    phases = c(3*pi/2, 0, pi/2)\n  ) %&gt;%\n  white_noise(mean = 0, sd = 1e-5) %&gt;%\n  exp_decay(decay_tau = 0.5) %&gt;%\n  length_norm()\n\nwv_for_fft %&gt;%\n  waveform_plot(x = \"t (s)\", y = \"f(t)\")\n\n\n\n\n\n\n\n\nWe can take and plot the FFT of this waveform simply with compute_fft() (remember to length_norm() before you run an FFT). Here we will take our noisy signal, do an FFT, and make a PSD plpot of the first 100 Fourier coefficients:\n\nour_first_fft &lt;- wv_for_fft %&gt;%\n  compute_fft()\n\nour_first_fft %&gt;%\n  fft_plot(show = \"psd\", x = \"Hz\", y = \"PSD\")\n\n\n\n\n\n\n\n\n(Read below to find out how to remove noise with FFT denoising!)\nSince there is more than just spectral density, we can also plot everything out of the FFT. What we will see is the real, imaginary, modulus of every Fourier coefficient as well as every PSD value.\n\nour_first_fft %&gt;%\n  fft_plot(show = \"everything\")\n\n\n\n\n\n\n\n\nNow let’s go backwards with the inverse FFT to regenerate a waveform from FFT data. We do this with the inverse_fft() function. The inverse_fft() function is somewhat tricky: It takes a data.frame of an incoming FFT as the second argument, and a data.frame of an incoming waveform as the first argument. The waveform is necessary so that the inverse operation has somewhere to put the data; it must be a waveform compatible with the original waveform. Here waveform(duration_s = 1.0, sr = 200) is the same call we started the original waveform with. And, as usual, we will call length_norm() as the last step in producing a waveform.\n\nwv_recreated &lt;- waveform(duration_s = 1.0, sr = 200) %&gt;%\n  inverse_fft(our_first_fft) %&gt;%\n  length_norm()\n\nwv_recreated %&gt;%\n  waveform_plot(title = \"Recreated Waveform\", x = \"t (s)\", y = \"f(t)\")\n\n\n\n\n\n\n\n\n\n\nSignal Denoising\nSignal denoising is a simple way to remove noise from a signal through the following steps:1\n\nFFT the noisy signal\nInspect the power spectral density (PSD) for each Fourier coefficient\nObserve that the coefficients encoding the signal have a higher PSD than the noise coefficients.\nZero the coefficients that do not meet a PSD threshold.\nRun and inverse FFT to reconstruct a waveform with reduced noise.\n\nAll of these steps can be accomplished with functions in fftpipe.\n\nCreate Clean and Noisy Signals\nLet’s make the sample rate higher than we have been using so far so that it can capture the high frequency white noise better. First, let’s make a clean signal and inspect its waveform and PSD plot.\n\nwv &lt;- waveform(duration_s = 1.0, sr = 500) \n\nwv_clean &lt;- wv %&gt;%\n  cos_sum(\n    freqs = c(5, 10, 20), \n    amplitudes = c(1.0, 0.875, 0.75), \n    phases = c(3*pi/2, 0, pi/2)\n  )\n\nwv_clean_fft &lt;- wv_clean %&gt;%\n  length_norm() %&gt;%\n  compute_fft()\n\nCreate the plots of the clean signal:\n\nwv_clean %&gt;%\n  length_norm() %&gt;%\n  waveform_plot(\n    title = \"Clean Signal\",\n    x = \"t (s)\", \n    y = \"f(t)\"\n  )\n\n\n\n\n\n\n\n\n\nwv_clean_fft %&gt;%\n  fft_plot(title = \"PSD of Fourier Coefficients, Clean Signal\", x = \"Hz\", y = \"PSD\")\n\n\n\n\n\n\n\n\nNow let’s add some noise!\nThe white_noise() function adds noise from a Gaussian distribution to the signal.\n\nset.seed(123)\n\nwv_noisy &lt;- wv_clean %&gt;%\n  white_noise(mean = 0, sd = 1e-3) %&gt;%\n    length_norm()\n\nwv_noisy_fft &lt;- wv_noisy %&gt;%\n  compute_fft()\n\nAs before, let’s plot the waveform and the PSD of the first half of Fourier coefficients.\n\nwv_noisy %&gt;%\n  waveform_plot(\n    title = \"Noisy Signal\",\n    x = \"t (s)\", \n    y = \"f(t)\"\n  )\n\n\n\n\n\n\n\n\n\nwv_noisy_fft %&gt;%\n  fft_plot(title = \"PSD of Fourier Coefficients, Noisy Signal\", x = \"Hz\", y = \"PSD\")\n\n\n\n\n\n\n\n\nNote that a bunch of Fourier coefficients have lit up with very small PSD values. When we drop these coefficients to zero, we will recover clean Fourier coefficients. Then, when we do an inverse Fourier transform on the cleaned coefficients, we will recover the signal from the noise.\n\nwv_noisy_but_cleaned &lt;- wv_noisy_fft %&gt;%\n  denoise_fft(psd_thresh = 5e-2) %&gt;%\n  inverse_fft(wv, .) %&gt;%\n  length_norm()\n\nwv_noisy_but_cleaned %&gt;%\n  waveform_plot(\n    title = \"Waveform With Noise Removed\", \n    x = \"t (s)\", \n    y = \"f(t)\"\n  )"
  },
  {
    "objectID": "posts/fftpipe/index.html#additional-resources",
    "href": "posts/fftpipe/index.html#additional-resources",
    "title": "R: FFT with fftpipe",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nBrunton, Steve. Denoising Data with FFT [Python] https://youtu.be/s2K1JfNR7Sc\nNeto, João, Fourier Transform: A R Tutorial http://www.di.fc.ul.pt/~jpn/r/fourier/fourier.html"
  },
  {
    "objectID": "posts/moldyn/index.html#references",
    "href": "posts/moldyn/index.html#references",
    "title": "Julia: Molecular Dynamics of HCl",
    "section": "References",
    "text": "References\nAtkins, P. W. & De Paula, J. Atkins’ Physical Chemistry. (W.H. Freeman, New York, 2006).\nCramer, C. J. Essentials of Computational Chemistry: Theories and Models. (Wiley, Chichester, West Sussex, England ; Hoboken, NJ, 2004)."
  },
  {
    "objectID": "posts/moldyn/index.html#background",
    "href": "posts/moldyn/index.html#background",
    "title": "Julia: Molecular Dynamics of HCl",
    "section": "",
    "text": "Molecular dynamics models the motion of atoms within molecules using classical mechanics calculations. Molecular dynamics envisions atoms as balls on springs and calculates the accelerations of atoms within the system in a potential energy force field that has terms for several types of motions in the molecule. In this post, I will use the letter U to denote potential energy. Typical force fields model the following potentials: \\[ U = U_{stretch} + U_{angle} + U_{dihedral} + U_{improper} \\] For a complete description of the force field terms and motions, I refer the reader to Chapter 3 of the Cramer text referenced at the bottom of this document. In this project, I only model bond stretch energy so I could keep the code simple. The notation I will use in this post and code mostly comes from Chapter 3 of the Cramer text.\n\n\nThe stretch potential energy of a bond between atoms A and i is denoted Ustretch and has the following form: \\[ U_{stretch} = {1 \\over 2}k_{Ai}(r_{Ai}-r_{Ai,eq})^2 \\] Where kAi is the spring constant of the bond, rAi,eq is the equilibrium distance between atoms A and B and rAB is the instantaneous distance between the atoms. Since I am only modeling the stretch energy in this project, I will shorten Ustretch to U from here onward.\nThe first derivative of the stretch energy which is used to calculate the stretch forces acting upon an atom by the other atoms it is bonded to is: \\[ {\\partial U \\over \\partial x_A}=\\sum_{i} {\\partial U \\over \\partial r_{Ai}} {\\partial r_{Ai} \\over \\partial x_A} \\] Where the summation is over the atoms bonded to A and i refers to the other atoms. Similarly to x axis potential, the y and z potentials are: \\[ {\\partial U \\over \\partial y_A}=\\sum_{i} {\\partial U \\over \\partial r_{Ai}} {\\partial r_{Ai} \\over \\partial y_A} \\] \\[ {\\partial U \\over \\partial z_A}=\\sum_{i} {\\partial U \\over \\partial r_{Ai}} {\\partial r_{Ai} \\over \\partial z_A} \\] The partial derivatives of rAi for each x, y, z coordinate are: \\[ {\\partial r_{Ai} \\over \\partial x_A} = {x_A-x_i \\over \\sqrt{(x_A-x_i)^2 + (y_A-y_i)^2 + (z_A-z_i)^2}} \\] \\[ {\\partial r_{Ai} \\over \\partial y_A} = {y_A-y_i \\over \\sqrt{(x_A-x_i)^2 + (y_A-y_i)^2 + (z_A-z_i)^2}} \\] \\[ {\\partial r_{Ai} \\over \\partial z_A} = {z_A-z_i \\over \\sqrt{(x_A-x_i)^2 + (y_A-y_i)^2 + (z_A-z_i)^2}} \\] Finally, the partial derivative of stretch energy with respect to bond distance rAi is: \\[ {\\partial U \\over \\partial r_{Ai}} = k_{Ai}(r_{Ai}-r_{Ai,eq}) \\]\n\n\n\nThe analytical period of a harmonic oscillator that models the interatomic bonds in this simulation is: \\[ {1 \\over \\mu} = {1 \\over m_1} + {1 \\over m_2} \\]\n\\[ T = \\sqrt{\\mu \\over k_b} \\] where mu is the reduced mass, m1 and m2 are the masses of the atoms (in kg) and kb is the spring constant of the bond. T is the period of the oscillation in seconds. While I do not use this equation in the simulation, I do use it to verify the simulation is producing physically valid output.\n\n\n\nTo propagate the trajectory over time, I use the velocity Verlet algorithm. At each time step, I perform the algorithm for each atom. The steps of the algorithm are as follows: \\[ \\mathbf x_{t+1} = \\mathbf x_t + \\mathbf {v}_t \\Delta t + \\mathbf a_t (\\Delta t)^2 \\] \\[ \\mathbf v_{t+{1 \\over 2}} = \\mathbf v_t + {1 \\over 2} \\mathbf a_i \\Delta t \\] \\[ \\mathbf a_{i+1} = -{\\mathbf \\nabla_i \\over m} \\] \\[ \\mathbf v_{i+1} = \\mathbf v_{t+{1 \\over 2}} + {1 \\over 2}\\mathbf a_{i+1} \\Delta t \\]\n\n\n\nAs diagnostic metrics to assess the proper behavior of the simulation, I calculate the kinetic, potential, and total energy of the system at each time step. For the kinetic energy, I just sum over the kinetic energies of all the atoms to arrive at the total kinetic energy Ek: \\[ E_k = \\sum_i {1 \\over 2} m_i v_i^2 \\] Since the only energy is stretch energy in this simulation, I sum over the stretch energy over all atoms to find the total potential energy Ep: \\[ E_p = \\sum_i U_i \\]"
  },
  {
    "objectID": "posts/moldyn/index.html#methods",
    "href": "posts/moldyn/index.html#methods",
    "title": "Julia: Molecular Dynamics of HCl",
    "section": "Methods",
    "text": "Methods\nIn this section I describe the code that I wrote to run the simulation.\n\n1H35Cl Properties\nIn this simulation, I model 1H35Cl, as it is a classic molecule used to learn physical chemistry. The values I use to model the bond motion are:\n\n\n\n\n\n\n\n\n\nQuantity\nVariable\nValue\nUnits\n\n\n\n\nspring constant\nkAi\n516.0\nN/m\n\n\nequilibrium bond distance\nrAi,eq\n1.57 x 10-10\nm\n\n\nmass of hydrogen 1 atom\nm1\n1\namu\n\n\nmass of chlorine 35 atom\nm2\n35\namu\n\n\n\nkAi and rAi,eq are from Atkins and de Paula (below), page 454. Masses for 1H35Cl are converted from atomic mass units to kilograms in the simulation code. The analytical period of oscillation of the 1H35Cl bond is 11 fs, as calcualted below. This value will be used to analyze the period of oscillation in the results and discussion sections.\n\n\nDefine Constants\nkg_per_amu converts amu to kg. num_steps is the total number of time steps to run the simulation (delta t is 1 x 10-18 s, as will be explained below.)\n\nkg_per_amu = 1.661e-27\nnum_steps = 25000;  # Semicolon to suppress code output from final document\n\n\n\nVectors and matrices holding simulation information.\n\n# Positions (xs), velocities (vs), and accelerations (accels) arrays:\n# First axis is timestep\n# Second axis are atoms\n# Third axis is x,y,z (meters for position, m/s for velocities)\n\nvs = zeros(Float64, num_steps, 2, 3)\nxs = zeros(Float64, num_steps, 2, 3)\naccels = zeros(Float64, num_steps, 2, 3)\n\n# Masses: The masses of each atom (kg)\nms = zeros(Float64, 2)\n\n# Total kinetic energies: The total kinetic energy of the system\n# at each timestep.\n\ntkes = zeros(Float64, num_steps)\n\n# Total potential energies: Total potential energy of the system\n# at each timestep\n\ntpes = zeros(Float64, num_steps);  # Semicolon to suppress code output from final document\n\n\n\nInitialize Simulation\nSet the initial conditions of the simulation, including start positions and velocities of the atoms and their masses. Also set the topology to the 1H35Cl bond here.\n\n# Equilibrium bond length for HCl\nr_ab_eq_hcl = 1.57e-10\n\n# Assume Cl is at 0,0,0 and H lies along the x-axis\n\n# HCl equilibrium bond length\nxs[1, 2, :] = [r_ab_eq_hcl*0.999, 0.0, 0.0]\n\n# Masses, Cl first then H\nms[1] = 35 * kg_per_amu\nms[2] = 1 * kg_per_amu\n\n# 1-2 Bonds\n# Rows are bonds, columns are atoms participating in bond\n# Note: This is specifying edges on a graph, so 1-2 also has 2-1\n\none_two_bonds = [1 2; 2 1]\n\n# 1-2 Bonds, stretch constants\n# Note: There is the same constant for each direction of the bond\n# HCl bond constant 516 N/m according to Atkins and de Paula, pg. 454\n\none_two_bonds_kab = [516.0 516.0]\n\n# 1-2 Bonds, equilibrium distances\n# Note: There is a distance for each direction of the bond\n\none_two_bonds_req = [r_ab_eq_hcl r_ab_eq_hcl];  # Semicolon to suppress code output from final document\n\n\n\nFunctions to Run the Simulation\nWhile the code above defines the data for the simulation to operate on, these functions are what perform the calculations on those data.\n\n# Distance from atom a to b\nfunction r_ab(a, b)\n    sqrt(sum((a-b).^2))\nend\n\n# Stretch energy for a 1-2 bond\nfunction stretch_energy(a, b, k_ab, r_ab_eq) \n    0.5*k_ab*(r_ab(a, b)-r_ab_eq)^2\nend\n\n# Kinetic energy for an atom\nfunction kinetic_energy(vs::Array{Float64}, ms::Array{Float64}, timestep, atom)\n    v = vs[timestep, atom, :]\n    m = ms[atom]\n    0.5 * m * sum(v.^2)\nend\n\n# Stretch energy gradient for a single 1-2 bond\nfunction stretch_gradient(a, b, k_ab, r_ab_eq)\n    du_drab = 0.5 * k_ab * (2*r_ab(a, b)-2*r_ab_eq)\n    drab_dxa = (a[1]-b[1])/r_ab(a, b)\n    drab_dya = (a[2]-b[2])/r_ab(a, b)\n    drab_dza = (a[3]-b[3])/r_ab(a, b)\n\n    [drab_dxa, drab_dya, drab_dza] * du_drab\nend\n\n# Propagate 1-2 bond stretch trajectories\nfunction stretch_velocity_verlet(xs, vs, accels, tkes, tpes, one_two_bonds, one_two_bonds_kab, one_two_bonds_req, ms, dt, num_steps)\n    for time_i in 1:num_steps-1\n        for bond_i in [1 2]\n            k_ab = one_two_bonds_kab[bond_i]\n            r_eq = one_two_bonds_req[bond_i]\n            atom_a = one_two_bonds[bond_i, 1]\n            atom_b = one_two_bonds[bond_i, 2]\n            xs[time_i+1, atom_a, :] = xs[time_i, atom_a, :] + vs[time_i, atom_a, :] * dt + accels[time_i, atom_a, :] * dt^2\n            v_mid = vs[time_i, atom_a, :] + 0.5 * accels[time_i, atom_a, :] * dt\n            accels[time_i+1, atom_a, :] = -stretch_gradient(xs[time_i, atom_a, :], xs[time_i, atom_b, :], k_ab, r_eq) / ms[atom_a]\n            vs[time_i+1, atom_a, :] = v_mid + 0.5 * accels[time_i+1, atom_a, :] * dt\n        end\n\n        tkes[time_i] = total_kinetic_energy(vs, ms, time_i)\n        tpes[time_i] = total_stretch_energy(xs, one_two_bonds, one_two_bonds_kab, one_two_bonds_req, time_i)\n    end\n\n    tkes[num_steps] = total_kinetic_energy(vs, ms, num_steps)\n    tpes[num_steps] = total_stretch_energy(xs, one_two_bonds, one_two_bonds_kab, one_two_bonds_req, num_steps)\n\n    return nothing\nend\n\n# Determine the total kinetic energy of the system\nfunction total_kinetic_energy(vs::Array{Float64}, ms::Array{Float64}, timestep::Int)\n    sum([kinetic_energy(vs, ms, timestep, atom) for atom in eachindex(ms)])\nend\n\n# Determine total stretch energy of the system.\nfunction total_stretch_energy(xs::Array{Float64}, one_two_bonds::Array{Int}, one_two_bonds_kab::Array{Float64}, one_two_bonds_req::Array{Float64}, timestep::Int)\n    stretch_energies = zeros(Float64, length(one_two_bonds_kab))\n    \n    for i in eachindex(one_two_bonds_kab)\n        atom_a = one_two_bonds[i, 1]\n        atom_b = one_two_bonds[i, 2]\n        k_ab = one_two_bonds_kab[i]\n        r_eq = one_two_bonds_req[i]\n        pos_a = xs[timestep, atom_a, 1:3]\n        pos_b = xs[timestep, atom_b, 1:3]\n        stretch_energies[i] = stretch_energy(pos_a, pos_b, k_ab, r_eq)\n    end\n\n    # Divide by 2.0 to prevent double counting the 1-2 bonds\n    sum(stretch_energies) / 2.0\nend;  # Semicolon to suppress code output from final document\n\n\n\nVelocity Verlet\nNow for the fun part: Run the simulation! The following code block calls the functions to operate on the data above and calculate the trajectory of 1H35Cl.\n\ndt = 1e-18\nstretch_velocity_verlet(xs, vs, accels, tkes, tpes, one_two_bonds, one_two_bonds_kab, one_two_bonds_req, ms, dt, num_steps);  # Semicolon to suppress code output from final document"
  },
  {
    "objectID": "posts/moldyn/index.html#results",
    "href": "posts/moldyn/index.html#results",
    "title": "Julia: Molecular Dynamics of HCl",
    "section": "Results",
    "text": "Results\n\nX Coordinate of Hydrogen\nSince the 1H35Cl molecule lies on the x axis, to find the period of oscillation we can look at plot of the hydrogen atom’s x-coordinate versus time, as shown below:\n\nx_axis = eachindex(xs[:, 2, 1]) / 1000\nh_x_axis_trajectory = xs[:, 2, 1]\nhydrogen_plot = plot(x_axis, h_x_axis_trajectory, xlabel=\"Time (fs)\", ylabel=\"H x position (m)\", legend=false)\ndisplay(hydrogen_plot)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe plot shows the period of oscillation is 11 fs, which agrees with the analytical calculation above.\n\n\nKinetic, Potential, and Total Energy\nIdeally, at each time step the total energy of the system should remain constant. To verify this, the following plot displays the kinetic, potential, and total energy in the simulation (please ignore the warning messages about plot ticks):\n\nplot(x_axis, tkes, xlabel=\"Time (fs)\", ylabel=\"J\", label=\"Ek\")\nplot!(x_axis, tpes, label=\"Ep\")\nenergy_plot = plot!(x_axis, tpes + tkes, label=\"total\")\ndisplay(energy_plot)\n\n┌ Warning: No strict ticks found\n└ @ PlotUtils ~/.julia/packages/PlotUtils/jEGKP/src/ticks.jl:191\n┌ Warning: No strict ticks found\n└ @ PlotUtils ~/.julia/packages/PlotUtils/jEGKP/src/ticks.jl:191\n┌ Warning: No strict ticks found\n└ @ PlotUtils ~/.julia/packages/PlotUtils/jEGKP/src/ticks.jl:191\n┌ Warning: No strict ticks found\n└ @ PlotUtils ~/.julia/packages/PlotUtils/jEGKP/src/ticks.jl:191\n┌ Warning: No strict ticks found\n└ @ PlotUtils ~/.julia/packages/PlotUtils/jEGKP/src/ticks.jl:191\n┌ Warning: No strict ticks found\n└ @ PlotUtils ~/.julia/packages/PlotUtils/jEGKP/src/ticks.jl:191\n┌ Warning: No strict ticks found\n└ @ PlotUtils ~/.julia/packages/PlotUtils/jEGKP/src/ticks.jl:191"
  },
  {
    "objectID": "posts/moldyn/index.html#discussion",
    "href": "posts/moldyn/index.html#discussion",
    "title": "Julia: Molecular Dynamics of HCl",
    "section": "Discussion",
    "text": "Discussion\nThis was my first project in the Julia programming language, and I am pleased with the results. The analytical period agrees with the simulation period of 1H35Cl. I find that very exciting! However, the total energy of the system increases slightly over the run of the trajectory, which means that energy is not being conserved by the algorithm. To combat this upward energy creep, I made the time step 1 x 10-18 s. This seemed to help the energy creep, but did not ameliorate the situation entirely.\nFuture directions of this work could include:\n\nIncorporating Uangle energy and simulating 1H216O.\nSimulating multiple molecules at once.\n\nThanks for reading!"
  }
]